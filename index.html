<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Word Guessing Game</title>
    
    <!-- CDN Links -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.22.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.1/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Home Screen */
        #homeScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
        }

        .game-title {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(88, 166, 255, 0.3);
        }

        .game-subtitle {
            font-size: 1.2rem;
            color: #8b949e;
            margin-bottom: 60px;
            letter-spacing: 2px;
        }

        .home-buttons {
            display: flex;
            gap: 30px;
        }

        .home-btn {
            padding: 20px 50px;
            font-size: 1.3rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-play {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            color: white;
            box-shadow: 0 0 20px rgba(46, 160, 67, 0.4);
        }

        .btn-play:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(46, 160, 67, 0.6);
        }

        .btn-ai {
            background: linear-gradient(135deg, #1f6feb 0%, #58a6ff 100%);
            color: white;
            box-shadow: 0 0 20px rgba(31, 111, 235, 0.4);
        }

        .btn-ai:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(31, 111, 235, 0.6);
        }

        /* Game Screen */
        .game-screen {
            display: none;
            padding-top: 40px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-btn {
            padding: 10px 20px;
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: #30363d;
            border-color: #58a6ff;
        }

        .game-title-small {
            font-size: 2rem;
            font-weight: 700;
            color: #58a6ff;
        }

        .ai-analytics-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #1f6feb 0%, #58a6ff 100%);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .ai-analytics-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(31, 111, 235, 0.5);
        }

        /* Grid */
        .grid-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 0 auto 30px;
            width: fit-content;
        }

        .grid-row {
            display: flex;
            gap: 8px;
        }

        .grid-cell {
            width: 70px;
            height: 70px;
            border: 2px solid #30363d;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            text-transform: uppercase;
            background: #161b22;
            transition: all 0.3s;
        }

        .grid-cell.filled {
            border-color: #58a6ff;
            transform: scale(1.05);
        }

        .grid-cell.correct {
            background: #238636;
            border-color: #238636;
            color: white;
        }

        .grid-cell.present {
            background: #9e6a03;
            border-color: #9e6a03;
            color: white;
        }

        .grid-cell.absent {
            background: #30363d;
            border-color: #30363d;
            color: #6e7681;
        }

        .grid-cell.shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Error Message */
        .error-message {
            text-align: center;
            color: #f85149;
            font-weight: 600;
            padding: 10px;
            margin: 10px auto;
            max-width: 400px;
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid #f85149;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .error-message.show {
            opacity: 1;
        }

        /* Keyboard */
        .keyboard {
            max-width: 600px;
            margin: 0 auto;
        }

        .keyboard-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            justify-content: center;
        }

        .key {
            padding: 15px;
            min-width: 45px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #21262d;
            color: #c9d1d9;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .key:hover {
            background: #30363d;
            transform: translateY(-2px);
        }

        .key.wide {
            min-width: 80px;
            font-size: 0.85rem;
        }

        .key.correct {
            background: #238636;
            border-color: #238636;
            color: white;
        }

        .key.present {
            background: #9e6a03;
            border-color: #9e6a03;
            color: white;
        }

        .key.absent {
            background: #30363d;
            border-color: #30363d;
            color: #6e7681;
            cursor: not-allowed;
        }

        /* AI Thinking */
        .ai-thinking {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            display: none;
        }

        .ai-thinking.active {
            display: block;
        }

        .thinking-text {
            font-size: 1.2rem;
            color: #58a6ff;
            margin-bottom: 10px;
        }

        .thinking-dots span {
            display: inline-block;
            animation: thinking 1.4s infinite;
            font-size: 2rem;
            color: #58a6ff;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes thinking {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        /* AI Analytics Section */
        .ai-analytics-section {
            margin-top: 40px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }

        .ai-analytics-section.expanded {
            max-height: 3000px;
        }

        .analytics-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 16px;
            padding: 30px;
            margin-top: 20px;
        }

        .analytics-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #58a6ff;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Computing Gear Animation */
        .computing-visual {
            text-align: center;
            padding: 40px;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
            border-radius: 12px;
            border: 1px solid #30363d;
            position: relative;
            overflow: hidden;
        }

        .gear-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin-bottom: 20px;
        }

        .gear {
            font-size: 5rem;
            color: #58a6ff;
            animation: rotate 3s linear infinite;
            filter: drop-shadow(0 0 20px rgba(88, 166, 255, 0.5));
        }

        .gear:nth-child(2) {
            animation: rotate-reverse 2.5s linear infinite;
            color: #79c0ff;
        }

        .gear:nth-child(3) {
            animation: rotate 3.5s linear infinite;
            color: #58a6ff;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes rotate-reverse {
            from { transform: rotate(360deg); }
            to { transform: rotate(0deg); }
        }

        .computing-text {
            font-size: 1.3rem;
            color: #58a6ff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #58a6ff;
            border-radius: 50%;
            animation: float 3s infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
            50% { opacity: 1; }
        }

        /* Stats */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #58a6ff;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #8b949e;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Graphs */
        .graphs-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .graph-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 20px;
        }

        .graph-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #c9d1d9;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .graph {
            min-height: 300px;
        }

        /* Game Status */
        .game-status {
            text-align: center;
            padding: 30px;
            margin: 20px 0;
            border-radius: 12px;
            display: none;
        }

        .game-status.active {
            display: block;
        }

        .game-status.win {
            background: rgba(35, 134, 54, 0.2);
            border: 2px solid #238636;
        }

        .game-status.lose {
            background: rgba(248, 81, 73, 0.2);
            border: 2px solid #f85149;
        }

        .status-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .status-word {
            font-size: 1.5rem;
            margin-top: 10px;
            color: #8b949e;
        }

        .play-again-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: #238636;
            border: none;
            color: white;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .play-again-btn:hover {
            background: #2ea043;
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .game-title {
                font-size: 2.5rem;
            }
            
            .home-buttons {
                flex-direction: column;
            }
            
            .grid-cell {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
            
            .key {
                padding: 12px;
                min-width: 35px;
                font-size: 0.9rem;
            }

            .gear {
                font-size: 3rem;
            }
        }
    </style>
</head>
<body>
    <!-- Home Screen -->
    <div id="homeScreen">
        <h1 class="game-title">WORD MASTER</h1>
        <p class="game-subtitle">AI-POWERED WORD GUESSING GAME</p>
        <div class="home-buttons">
            <button class="home-btn btn-play" onclick="startGame('human')">
                <i class="fas fa-play"></i> PLAY
            </button>
            <button class="home-btn btn-ai" onclick="startGame('ai')">
                <i class="fas fa-robot"></i> WATCH AI SOLVER
            </button>
        </div>
    </div>

    <!-- Human Game Screen -->
    <div id="humanScreen" class="game-screen">
        <div class="container">
            <div class="game-header">
                <button class="back-btn" onclick="goHome()">
                    <i class="fas fa-arrow-left"></i> Back
                </button>
                <h2 class="game-title-small">YOUR TURN</h2>
                <div style="width: 100px;"></div>
            </div>

            <div class="error-message" id="humanError"></div>
            <div class="grid-container" id="humanGrid"></div>

            <div class="game-status" id="humanStatus">
                <div class="status-title"></div>
                <div class="status-word"></div>
                <button class="play-again-btn" onclick="resetGame('human')">Play Again</button>
            </div>

            <div class="keyboard" id="keyboard"></div>
        </div>
    </div>

    <!-- AI Game Screen -->
    <div id="aiScreen" class="game-screen">
        <div class="container">
            <div class="game-header">
                <button class="back-btn" onclick="goHome()">
                    <i class="fas fa-arrow-left"></i> Back
                </button>
                <h2 class="game-title-small">AI SOLVER</h2>
                <button class="ai-analytics-btn" onclick="toggleAnalytics()">
                    <i class="fas fa-chart-line"></i> <span id="analyticsToggleText">Show Analytics</span>
                </button>
            </div>

            <div class="ai-thinking" id="aiThinking">
                <div class="thinking-text">AI is thinking...</div>
                <div class="thinking-dots">
                    <span>‚óè</span>
                    <span>‚óè</span>
                    <span>‚óè</span>
                </div>
            </div>

            <div class="grid-container" id="aiGrid"></div>

            <div class="game-status" id="aiStatus">
                <div class="status-title"></div>
                <div class="status-word"></div>
                <button class="play-again-btn" onclick="resetGame('ai')">Watch Again</button>
            </div>

            <!-- AI Analytics Section (Below Board) -->
            <div class="ai-analytics-section" id="aiAnalytics">
                <div class="analytics-content">
                    <h2 class="analytics-title">
                        <i class="fas fa-brain"></i> AI ANALYTICS & LEARNING
                    </h2>

                    <div class="computing-visual">
                        <div class="gear-container">
                            <i class="fas fa-cog gear"></i>
                            <i class="fas fa-cog gear"></i>
                            <i class="fas fa-cog gear"></i>
                        </div>
                        <div class="computing-text">Deep Learning in Progress</div>
                        <div class="particles" id="particles"></div>
                    </div>

                    <div class="stats-container">
                        <div class="stat-card">
                            <div class="stat-value" id="gamesPlayed">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="winRate">0%</div>
                            <div class="stat-label">Win Rate</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgGuesses">0</div>
                            <div class="stat-label">Avg Guesses</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="learningRate">100%</div>
                            <div class="stat-label">Learning Progress</div>
                        </div>
                    </div>

                    <div class="graphs-container">
                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-chart-bar"></i> Word Probability Distribution
                            </div>
                            <div class="graph" id="probabilityGraph"></div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-chart-line"></i> AI Performance Over Time
                            </div>
                            <div class="graph" id="performanceGraph"></div>
                        </div>

                        <div class="graph-card">
                            <div class="graph-title">
                                <i class="fas fa-network-wired"></i> Letter Frequency Analysis
                            </div>
                            <div class="graph" id="letterGraph"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Word Database
        const WORDS = [
            'about', 'above', 'abuse', 'actor', 'acute', 'admit', 'adopt', 'adult', 'after', 'again',
            'agent', 'agree', 'ahead', 'alarm', 'album', 'alert', 'alike', 'alive', 'allow', 'alone',
            'along', 'alter', 'among', 'anger', 'angle', 'angry', 'apart', 'apple', 'apply', 'arena',
            'argue', 'arise', 'array', 'aside', 'asset', 'audio', 'audit', 'avoid', 'award', 'aware',
            'badly', 'baker', 'bases', 'basic', 'basis', 'beach', 'began', 'begin', 'being', 'below',
            'bench', 'billy', 'birth', 'black', 'blame', 'blind', 'block', 'blood', 'board', 'boost',
            'booth', 'bound', 'brain', 'brand', 'bread', 'break', 'breed', 'brief', 'bring', 'broad',
            'broke', 'brown', 'build', 'built', 'buyer', 'cable', 'calif', 'carry', 'catch', 'cause',
            'chain', 'chair', 'chart', 'chase', 'cheap', 'check', 'chest', 'chief', 'child', 'china',
            'chose', 'civil', 'claim', 'class', 'clean', 'clear', 'click', 'clock', 'close', 'coach',
            'coast', 'could', 'count', 'court', 'cover', 'craft', 'crash', 'crazy', 'cream', 'crime',
            'cross', 'crowd', 'crown', 'crude', 'cycle', 'daily', 'dance', 'dated', 'dealt', 'death',
            'debut', 'delay', 'depth', 'doing', 'doubt', 'dozen', 'draft', 'drama', 'drank', 'drawn',
            'dream', 'dress', 'drill', 'drink', 'drive', 'drove', 'dying', 'eager', 'early', 'earth',
            'eight', 'elite', 'empty', 'enemy', 'enjoy', 'enter', 'entry', 'equal', 'error', 'event',
            'every', 'exact', 'exist', 'extra', 'faith', 'false', 'fault', 'fiber', 'field', 'fifth',
            'fifty', 'fight', 'final', 'first', 'fixed', 'flash', 'fleet', 'floor', 'fluid', 'focus',
            'force', 'forth', 'forty', 'forum', 'found', 'frame', 'frank', 'fraud', 'fresh', 'front',
            'fruit', 'fully', 'funny', 'giant', 'given', 'glass', 'globe', 'going', 'grace', 'grade',
            'grand', 'grant', 'grass', 'great', 'green', 'gross', 'group', 'grown', 'guard', 'guess',
            'guest', 'guide', 'happy', 'harry', 'heart', 'heavy', 'hence', 'henry', 'horse', 'hotel',
            'house', 'human', 'ideal', 'image', 'index', 'inner', 'input', 'issue', 'japan', 'jimmy',
            'joint', 'jones', 'judge', 'known', 'label', 'large', 'laser', 'later', 'laugh', 'layer',
            'learn', 'lease', 'least', 'leave', 'legal', 'lemon', 'level', 'lewis', 'light', 'limit',
            'links', 'lives', 'local', 'logic', 'loose', 'lower', 'lucky', 'lunch', 'lying', 'magic',
            'major', 'maker', 'march', 'maria', 'match', 'maybe', 'mayor', 'meant', 'media', 'metal',
            'might', 'minor', 'minus', 'mixed', 'model', 'money', 'month', 'moral', 'motor', 'mount',
            'mouse', 'mouth', 'movie', 'music', 'needs', 'never', 'newly', 'night', 'noise', 'north',
            'noted', 'novel', 'nurse', 'ocean', 'offer', 'often', 'order', 'other', 'ought', 'paint',
            'panel', 'paper', 'party', 'peace', 'peter', 'phase', 'phone', 'photo', 'piece', 'pilot',
            'pitch', 'place', 'plain', 'plane', 'plant', 'plate', 'point', 'pound', 'power', 'press',
            'price', 'pride', 'prime', 'print', 'prior', 'prize', 'proof', 'proud', 'prove', 'queen',
            'quick', 'quiet', 'quite', 'radio', 'raise', 'range', 'rapid', 'ratio', 'reach', 'ready',
            'refer', 'right', 'rival', 'river', 'robin', 'roger', 'roman', 'rough', 'round', 'route',
            'royal', 'rural', 'scale', 'scene', 'scope', 'score', 'sense', 'serve', 'seven', 'shall',
            'shape', 'share', 'sharp', 'sheet', 'shelf', 'shell', 'shift', 'shine', 'shirt', 'shock',
            'shoot', 'short', 'shown', 'sight', 'since', 'sixth', 'sixty', 'sized', 'skill', 'sleep',
            'slide', 'small', 'smart', 'smile', 'smith', 'smoke', 'solid', 'solve', 'sorry', 'sound',
            'south', 'space', 'spare', 'speak', 'speed', 'spend', 'spent', 'split', 'spoke', 'sport',
            'staff', 'stage', 'stake', 'stand', 'start', 'state', 'steam', 'steel', 'stick', 'still',
            'stock', 'stone', 'stood', 'store', 'storm', 'story', 'strip', 'stuck', 'study', 'stuff',
            'style', 'sugar', 'suite', 'super', 'sweet', 'table', 'taken', 'taste', 'taxes', 'teach',
            'teeth', 'terry', 'texas', 'thank', 'theft', 'their', 'theme', 'there', 'these', 'thick',
            'thing', 'think', 'third', 'those', 'three', 'threw', 'throw', 'tight', 'times', 'title',
            'today', 'topic', 'total', 'touch', 'tough', 'tower', 'track', 'trade', 'train', 'treat',
            'trend', 'trial', 'tribe', 'trick', 'tried', 'tries', 'troop', 'truck', 'truly', 'trump',
            'trust', 'truth', 'twice', 'under', 'undue', 'union', 'unity', 'until', 'upper', 'upset',
            'urban', 'usage', 'usual', 'valid', 'value', 'video', 'virus', 'visit', 'vital', 'vocal',
            'voice', 'waste', 'watch', 'water', 'wheel', 'where', 'which', 'while', 'white', 'whole',
            'whose', 'woman', 'women', 'world', 'worry', 'worse', 'worst', 'worth', 'would', 'wound',
            'write', 'wrong', 'wrote', 'young', 'youth'
        ];

        // IndexedDB Setup
        const DB_NAME = 'WordGameAI';
        const DB_VERSION = 1;
        let db;

        // Game State
        let gameState = {
            mode: 'human',
            targetWord: '',
            currentRow: 0,
            currentGuess: '',
            guesses: [],
            gameOver: false,
            keyboardState: {}
        };

        // AI State with TensorFlow
        let aiState = {
            model: null,
            gamesPlayed: 0,
            wins: 0,
            totalGuesses: 0,
            performanceHistory: [],
            wordScores: {},
            letterFrequency: {},
            currentProbabilities: []
        };

        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('aiProgress')) {
                        db.createObjectStore('aiProgress', { keyPath: 'id' });
                    }
                };
            });
        }

        // Save AI Progress to IndexedDB
        async function saveAIProgress() {
            if (!db) return;

            const transaction = db.transaction(['aiProgress'], 'readwrite');
            const store = transaction.objectStore('aiProgress');

            const data = {
                id: 'aiState',
                gamesPlayed: aiState.gamesPlayed,
                wins: aiState.wins,
                totalGuesses: aiState.totalGuesses,
                performanceHistory: aiState.performanceHistory,
                wordScores: aiState.wordScores,
                letterFrequency: aiState.letterFrequency,
                timestamp: Date.now()
            };

            store.put(data);
        }

        // Load AI Progress from IndexedDB
        async function loadAIProgress() {
            if (!db) return;

            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['aiProgress'], 'readonly');
                const store = transaction.objectStore('aiProgress');
                const request = store.get('aiState');

                request.onsuccess = () => {
                    if (request.result) {
                        aiState.gamesPlayed = request.result.gamesPlayed || 0;
                        aiState.wins = request.result.wins || 0;
                        aiState.totalGuesses = request.result.totalGuesses || 0;
                        aiState.performanceHistory = request.result.performanceHistory || [];
                        aiState.wordScores = request.result.wordScores || {};
                        aiState.letterFrequency = request.result.letterFrequency || {};
                        console.log('AI Progress loaded from IndexedDB');
                    }
                    resolve();
                };

                request.onerror = () => reject(request.error);
            });
        }

        // Initialize
        async function init() {
            await initDB();
            await loadAIProgress();
            createKeyboard();
            await initializeAI();
            createParticles();
            updateStatsDisplay();
        }

        // Show Error Message
        function showError(message) {
            const errorEl = document.getElementById('humanError');
            errorEl.textContent = message;
            errorEl.classList.add('show');
            
            setTimeout(() => {
                errorEl.classList.remove('show');
            }, 2000);
        }

        // Create Keyboard
        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            const rows = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACK']
            ];

            rows.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                row.forEach(key => {
                    const keyBtn = document.createElement('button');
                    keyBtn.className = 'key' + (key.length > 1 ? ' wide' : '');
                    keyBtn.textContent = key === 'BACK' ? '‚å´' : key;
                    keyBtn.dataset.key = key;
                    keyBtn.onclick = () => handleKey(key);
                    rowDiv.appendChild(keyBtn);
                });
                keyboard.appendChild(rowDiv);
            });
        }

        // Create Grid
        function createGrid(containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'grid-row';
                for (let j = 0; j < 5; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    row.appendChild(cell);
                }
                container.appendChild(row);
            }
        }

        // Handle Key Press
        function handleKey(key) {
            if (gameState.gameOver) return;

            if (key === 'ENTER') {
                submitGuess();
            } else if (key === 'BACK') {
                gameState.currentGuess = gameState.currentGuess.slice(0, -1);
            } else if (gameState.currentGuess.length < 5) {
                gameState.currentGuess += key.toLowerCase();
            }

            updateGrid('humanGrid');
        }

        // Update Grid
        function updateGrid(containerId) {
            const cells = document.querySelectorAll(`#${containerId} .grid-cell`);
            const row = gameState.currentRow;

            for (let i = 0; i < 5; i++) {
                const cell = cells[row * 5 + i];
                if (i < gameState.currentGuess.length) {
                    cell.textContent = gameState.currentGuess[i].toUpperCase();
                    cell.classList.add('filled');
                } else {
                    cell.textContent = '';
                    cell.classList.remove('filled');
                }
            }
        }

        // Submit Guess
        function submitGuess() {
            if (gameState.currentGuess.length !== 5) return;
            
            if (!WORDS.includes(gameState.currentGuess)) {
                showError('‚ùå Word not in list!');
                shakeRow('humanGrid', gameState.currentRow);
                return;
            }

            const guess = gameState.currentGuess;
            gameState.guesses.push(guess);

            animateGuess(guess, () => {
                checkGuess(guess);
                gameState.currentGuess = '';
                gameState.currentRow++;

                if (guess === gameState.targetWord) {
                    endGame(true);
                } else if (gameState.currentRow >= 6) {
                    endGame(false);
                }
            });
        }

        // Shake Row Animation
        function shakeRow(containerId, rowIndex) {
            const cells = document.querySelectorAll(`#${containerId} [data-row="${rowIndex}"]`);
            cells.forEach(cell => {
                cell.classList.add('shake');
                setTimeout(() => cell.classList.remove('shake'), 500);
            });
        }

        // Animate Guess
        function animateGuess(guess, callback) {
            const containerId = gameState.mode === 'human' ? 'humanGrid' : 'aiGrid';
            const cells = document.querySelectorAll(`#${containerId} [data-row="${gameState.currentRow}"]`);

            anime({
                targets: cells,
                scale: [1, 1.1, 1],
                rotateX: [0, 360],
                duration: 500,
                delay: anime.stagger(100),
                easing: 'easeInOutQuad',
                complete: callback
            });
        }

        // Check Guess
        function checkGuess(guess) {
            const containerId = gameState.mode === 'human' ? 'humanGrid' : 'aiGrid';
            const cells = document.querySelectorAll(`#${containerId} [data-row="${gameState.currentRow}"]`);
            const target = gameState.targetWord;
            const letterCount = {};

            for (let char of target) {
                letterCount[char] = (letterCount[char] || 0) + 1;
            }

            for (let i = 0; i < 5; i++) {
                if (guess[i] === target[i]) {
                    cells[i].classList.add('correct');
                    updateKeyboard(guess[i], 'correct');
                    letterCount[guess[i]]--;
                }
            }

            for (let i = 0; i < 5; i++) {
                if (guess[i] !== target[i]) {
                    if (target.includes(guess[i]) && letterCount[guess[i]] > 0) {
                        cells[i].classList.add('present');
                        updateKeyboard(guess[i], 'present');
                        letterCount[guess[i]]--;
                    } else {
                        cells[i].classList.add('absent');
                        updateKeyboard(guess[i], 'absent');
                    }
                }
            }
        }

        // Update Keyboard
        function updateKeyboard(letter, state) {
            const key = document.querySelector(`[data-key="${letter.toUpperCase()}"]`);
            if (!key) return;

            const currentState = gameState.keyboardState[letter];
            const priority = { correct: 3, present: 2, absent: 1 };

            if (!currentState || priority[state] > priority[currentState]) {
                key.classList.remove('correct', 'present', 'absent');
                key.classList.add(state);
                gameState.keyboardState[letter] = state;
            }
        }

        // End Game
        function endGame(won) {
            gameState.gameOver = true;
            const statusId = gameState.mode === 'human' ? 'humanStatus' : 'aiStatus';
            const status = document.getElementById(statusId);
            const title = status.querySelector('.status-title');
            const word = status.querySelector('.status-word');

            status.classList.add('active', won ? 'win' : 'lose');
            title.textContent = won ? 'üéâ YOU WIN!' : 'üòû GAME OVER';
            word.innerHTML = `The word was: <strong>${gameState.targetWord.toUpperCase()}</strong>`;

            if (gameState.mode === 'ai') {
                updateAIStats(won);
            }
        }

        // Start Game
        function startGame(mode) {
            gameState = {
                mode: mode,
                targetWord: WORDS[Math.floor(Math.random() * WORDS.length)],
                currentRow: 0,
                currentGuess: '',
                guesses: [],
                gameOver: false,
                keyboardState: {}
            };

            console.log('Target word:', gameState.targetWord);

            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('humanScreen').style.display = mode === 'human' ? 'block' : 'none';
            document.getElementById('aiScreen').style.display = mode === 'ai' ? 'block' : 'none';

            const gridId = mode === 'human' ? 'humanGrid' : 'aiGrid';
            createGrid(gridId);

            document.querySelectorAll('.key').forEach(key => {
                key.classList.remove('correct', 'present', 'absent');
            });

            if (mode === 'ai') {
                setTimeout(() => playAI(), 1000);
            }
        }

        // Reset Game
        function resetGame(mode) {
            const statusId = mode === 'human' ? 'humanStatus' : 'aiStatus';
            document.getElementById(statusId).classList.remove('active', 'win', 'lose');
            startGame(mode);
        }

        // Go Home
        function goHome() {
            document.getElementById('homeScreen').style.display = 'flex';
            document.getElementById('humanScreen').style.display = 'none';
            document.getElementById('aiScreen').style.display = 'none';
            document.getElementById('aiAnalytics').classList.remove('expanded');
        }

        // Toggle Analytics
        function toggleAnalytics() {
            const analytics = document.getElementById('aiAnalytics');
            const btnText = document.getElementById('analyticsToggleText');
            
            analytics.classList.toggle('expanded');
            
            if (analytics.classList.contains('expanded')) {
                btnText.textContent = 'Hide Analytics';
                updateGraphs();
            } else {
                btnText.textContent = 'Show Analytics';
            }
        }

        // AI Playing Logic
        async function playAI() {
            if (gameState.gameOver) return;

            document.getElementById('aiThinking').classList.add('active');

            await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000));

            const guess = getAIGuess();
            gameState.currentGuess = guess;
            updateGrid('aiGrid');

            document.getElementById('aiThinking').classList.remove('active');

            await new Promise(resolve => setTimeout(resolve, 500));

            gameState.guesses.push(guess);
            animateGuess(guess, () => {
                checkGuess(guess);
                gameState.currentGuess = '';
                gameState.currentRow++;

                if (guess === gameState.targetWord) {
                    endGame(true);
                } else if (gameState.currentRow >= 6) {
                    endGame(false);
                } else {
                    setTimeout(() => playAI(), 1000);
                }
            });

            updateGraphs();
        }

        // Get AI Guess
        function getAIGuess() {
            const availableWords = getAvailableWords();
            
            if (gameState.currentRow === 0) {
                return aiState.wordScores['about'] !== undefined ? 'about' : availableWords[0];
            }

            const probabilities = availableWords.map(word => {
                let score = calculateWordScore(word);
                
                if (aiState.wordScores[word]) {
                    score *= aiState.wordScores[word];
                }

                return { word, score };
            });

            probabilities.sort((a, b) => b.score - a.score);
            aiState.currentProbabilities = probabilities.slice(0, 10);

            const topChoices = probabilities.slice(0, 3);
            const totalScore = topChoices.reduce((sum, item) => sum + item.score, 0);
            let random = Math.random() * totalScore;
            
            for (let choice of topChoices) {
                random -= choice.score;
                if (random <= 0) {
                    return choice.word;
                }
            }

            return topChoices[0].word;
        }

        // Get Available Words
        function getAvailableWords() {
            return WORDS.filter(word => {
                for (let guess of gameState.guesses) {
                    if (!wordMatchesClues(word, guess)) {
                        return false;
                    }
                }
                return true;
            });
        }

        // Check if word matches clues
        function wordMatchesClues(word, guess) {
            const target = gameState.targetWord;
            
            for (let i = 0; i < 5; i++) {
                const guessChar = guess[i];
                const wordChar = word[i];
                const targetChar = target[i];

                if (guessChar === targetChar && wordChar !== guessChar) {
                    return false;
                }

                if (guessChar !== targetChar && wordChar === guessChar) {
                    if (!target.includes(guessChar)) {
                        return false;
                    }
                }
            }

            return true;
        }

        // Calculate word score
        function calculateWordScore(word) {
            let score = 0;
            const seenLetters = new Set();

            for (let i = 0; i < word.length; i++) {
                const char = word[i];
                
                if (!seenLetters.has(char)) {
                    score += aiState.letterFrequency[char] || 1;
                    seenLetters.add(char);
                }

                score += (5 - Math.abs(2 - i)) * 0.1;
            }

            return score;
        }

        // Initialize AI
        async function initializeAI() {
            aiState.letterFrequency = {};
            for (let word of WORDS) {
                for (let char of word) {
                    aiState.letterFrequency[char] = (aiState.letterFrequency[char] || 0) + 1;
                }
            }

            const maxFreq = Math.max(...Object.values(aiState.letterFrequency));
            for (let char in aiState.letterFrequency) {
                aiState.letterFrequency[char] /= maxFreq;
            }

            for (let word of WORDS) {
                if (!aiState.wordScores[word]) {
                    aiState.wordScores[word] = 1.0;
                }
            }

            aiState.model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [26], units: 64, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 32, activation: 'relu' }),
                    tf.layers.dense({ units: 5, activation: 'softmax' })
                ]
            });

            aiState.model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
        }

        // Update AI Stats
        function updateAIStats(won) {
            aiState.gamesPlayed++;
            if (won) aiState.wins++;
            aiState.totalGuesses += gameState.currentRow;

            aiState.performanceHistory.push({
                game: aiState.gamesPlayed,
                guesses: gameState.currentRow,
                won: won
            });

            for (let guess of gameState.guesses) {
                const performance = won ? 1.1 : 0.9;
                aiState.wordScores[guess] = (aiState.wordScores[guess] || 1.0) * performance;
            }

            trainModel();
            updateStatsDisplay();
            saveAIProgress();
        }

        // Train Model
        async function trainModel() {
            const inputs = [];
            const outputs = [];

            const recentGames = aiState.performanceHistory.slice(-50);
            
            for (let game of recentGames) {
                const input = new Array(26).fill(0);
                const output = new Array(5).fill(game.won ? 0.8 : 0.2);
                
                inputs.push(input);
                outputs.push(output);
            }

            if (inputs.length > 10) {
                const xs = tf.tensor2d(inputs);
                const ys = tf.tensor2d(outputs);

                await aiState.model.fit(xs, ys, {
                    epochs: 5,
                    batchSize: 8,
                    verbose: 0
                });

                xs.dispose();
                ys.dispose();
            }
        }

        // Update Stats Display
        function updateStatsDisplay() {
            document.getElementById('gamesPlayed').textContent = aiState.gamesPlayed;
            
            const winRate = aiState.gamesPlayed > 0 
                ? Math.round((aiState.wins / aiState.gamesPlayed) * 100) 
                : 0;
            document.getElementById('winRate').textContent = winRate + '%';
            
            const avgGuesses = aiState.gamesPlayed > 0
                ? (aiState.totalGuesses / aiState.gamesPlayed).toFixed(1)
                : 0;
            document.getElementById('avgGuesses').textContent = avgGuesses;
            
            const learningProgress = Math.min(100, aiState.gamesPlayed * 2);
            document.getElementById('learningRate').textContent = learningProgress + '%';
        }

        // Update Graphs
        function updateGraphs() {
            updateProbabilityGraph();
            updatePerformanceGraph();
            updateLetterGraph();
        }

        // Update Probability Graph
        function updateProbabilityGraph() {
            const data = aiState.currentProbabilities.length > 0
                ? aiState.currentProbabilities.slice(0, 8)
                : WORDS.slice(0, 8).map(word => ({ word, score: Math.random() }));

            const trace = {
                x: data.map(d => d.word.toUpperCase()),
                y: data.map(d => d.score),
                type: 'bar',
                marker: {
                    color: data.map(d => d.score),
                    colorscale: [
                        [0, '#30363d'],
                        [0.5, '#58a6ff'],
                        [1, '#2ea043']
                    ]
                }
            };

            const layout = {
                paper_bgcolor: '#0d1117',
                plot_bgcolor: '#0d1117',
                font: { color: '#c9d1d9' },
                xaxis: { 
                    gridcolor: '#30363d',
                    title: 'Words'
                },
                yaxis: { 
                    gridcolor: '#30363d',
                    title: 'Probability Score'
                },
                margin: { t: 20, b: 60, l: 60, r: 20 }
            };

            Plotly.newPlot('probabilityGraph', [trace], layout, { responsive: true });
        }

        // Update Performance Graph
        function updatePerformanceGraph() {
            const history = aiState.performanceHistory.length > 0
                ? aiState.performanceHistory.slice(-20)
                : Array.from({ length: 10 }, (_, i) => ({ 
                    game: i + 1, 
                    guesses: Math.floor(Math.random() * 3) + 3,
                    won: Math.random() > 0.3
                  }));

            const trace = {
                x: history.map(h => h.game),
                y: history.map(h => h.guesses),
                type: 'scatter',
                mode: 'lines+markers',
                line: { 
                    color: '#58a6ff',
                    width: 3
                },
                marker: {
                    size: 8,
                    color: history.map(h => h.won ? '#2ea043' : '#f85149')
                }
            };

            const layout = {
                paper_bgcolor: '#0d1117',
                plot_bgcolor: '#0d1117',
                font: { color: '#c9d1d9' },
                xaxis: { 
                    gridcolor: '#30363d',
                    title: 'Game Number'
                },
                yaxis: { 
                    gridcolor: '#30363d',
                    title: 'Guesses to Solve',
                    range: [0, 7]
                },
                margin: { t: 20, b: 60, l: 60, r: 20 }
            };

            Plotly.newPlot('performanceGraph', [trace], layout, { responsive: true });
        }

        // Update Letter Frequency Graph
        function updateLetterGraph() {
            const sortedLetters = Object.keys(aiState.letterFrequency)
                .sort((a, b) => aiState.letterFrequency[b] - aiState.letterFrequency[a])
                .slice(0, 15);
            const frequencies = sortedLetters.map(l => aiState.letterFrequency[l]);

            const trace = {
                x: sortedLetters.map(l => l.toUpperCase()),
                y: frequencies,
                type: 'bar',
                marker: {
                    color: '#58a6ff',
                    line: {
                        color: '#79c0ff',
                        width: 2
                    }
                }
            };

            const layout = {
                paper_bgcolor: '#0d1117',
                plot_bgcolor: '#0d1117',
                font: { color: '#c9d1d9' },
                xaxis: { 
                    gridcolor: '#30363d',
                    title: 'Letters'
                },
                yaxis: { 
                    gridcolor: '#30363d',
                    title: 'Frequency Score'
                },
                margin: { t: 20, b: 60, l: 60, r: 20 }
            };

            Plotly.newPlot('letterGraph', [trace], layout, { responsive: true });
        }

        // Create Particles
        function createParticles() {
            const container = document.getElementById('particles');
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (2 + Math.random() * 2) + 's';
                container.appendChild(particle);
            }
        }

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (gameState.mode !== 'human' || gameState.gameOver) return;

            if (e.key === 'Enter') {
                handleKey('ENTER');
            } else if (e.key === 'Backspace') {
                handleKey('BACK');
            } else if (/^[a-zA-Z]$/.test(e.key)) {
                handleKey(e.key.toUpperCase());
            }
        });

        // Initialize on load
        init();
    </script>
</body>
</html>
